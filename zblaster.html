<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2 Player PvE Zombie Shooter - Fullscreen, Custom Difficulty & Ready-Up</title>
<style>
  @font-face {
    font-family: 'PressStart2P';
    src: url('https://fonts.gstatic.com/s/pressstart2p/v12/8QIHdir7rE5N6gr8Q2qxnfNtlH1aTg.woff2') format('woff2');
  }
  :root {
    --main-color: #0f0;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; overflow: hidden;
    background: #222;
    font-family: 'PressStart2P', monospace, monospace;
    user-select: none;
    color: var(--main-color);
  }
  #gameCanvas {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100vw;
    height: 100vh;
    background: #111;
    border: none;
  }
  /* Main container for color selection + left menu */
  #colorSelectionWrapper {
    position: fixed;
    top:0; left:0; width: 100vw; height: 100vh;
    display: flex;
    background: #000;
    color: var(--main-color);
    user-select: none;
    overflow: hidden;
    z-index: 40;
  }
  /* Left menu with Upgrades/Shop/Options */
  #leftMenu {
    width: 140px;
    background: #111;
    border-right: 2px solid var(--main-color);
    display: flex;
    flex-direction: column;
    padding: 20px 10px;
    box-sizing: border-box;
  }
  #leftMenu button {
    background: none;
    border: 2px solid var(--main-color);
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    font-size: 14px;
    margin-bottom: 15px;
    padding: 12px 10px;
    cursor: pointer;
    border-radius: 10px;
    user-select: none;
    transition: background 0.3s;
  }
  #leftMenu button.active,
  #leftMenu button:hover {
    background: var(--main-color);
    color: #000;
  }

  /* Right main panel: color selection and settings */
  #colorSelectionScreen {
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    overflow-y: auto;
    padding: 10px 30px 40px 30px;
    text-align: center;
  }
  #colorSelectionScreen > div:first-child {
    font-size: 24px;
    margin-bottom: 15px;
  }
  #colorOptions {
    display: flex;
    gap: 40px;
    margin: 10px 0 25px 0;
  }
  .colorBox {
    width: 80px;
    height: 80px;
    border: 3px solid var(--main-color);
    cursor: pointer;
    position: relative;
    transition: outline 0.3s ease;
  }
  /* Player selection outlines */
  .colorBox.p1-selected {
    outline: 5px solid #00f;
  }
  .colorBox.p2-selected {
    outline: 5px solid #0ff;
  }
  /* Player ready glow */
  .colorBox.p1-ready {
    box-shadow: 0 0 15px 3px #00f;
  }
  .colorBox.p2-ready {
    box-shadow: 0 0 15px 3px #0ff;
  }
  #readyInstructions {
    margin-bottom: 15px;
    font-size: 14px;
    line-height: 1.4;
  }
  #modeToggle {
    margin-top: 10px;
    cursor: pointer;
    border: 2px solid var(--main-color);
    padding: 10px 20px;
    border-radius: 10px;
    user-select: none;
    width: 320px;
  }
  /* Replacing blitzToggle with checkbox: */
  #blitzToggleContainer {
    margin-top: 15px;
    width: 320px;
    border: 2px solid var(--main-color);
    border-radius: 10px;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    user-select: none;
    font-size: 14px;
  }
  #blitzToggleContainer label {
    cursor: pointer;
  }
  #difficultySelector {
    margin-top: 25px;
    border: 2px solid var(--main-color);
    padding: 20px;
    border-radius: 12px;
    width: 340px;
    text-align: left;
  }
  #difficultySelector label {
    font-size: 12px;
    display: block;
    margin-top: 12px;
    user-select: none;
  }
  #difficultySelector select {
    margin-top: 5px;
    width: 100%;
    font-family: 'PressStart2P', monospace;
    font-size: 12px;
    padding: 4px 6px;
  }
  .sliderContainer {
    margin-top: 12px;
  }
  .sliderContainer label {
    font-size: 11px;
  }
  .sliderContainer input[type=range] {
    width: 100%;
  }
  #customSliders {
    margin-top: 15px;
  }
  /* Leaderboard below difficulty selector */
  #leaderboardContainer {
    margin-top: 25px;
    width: 340px;
    border: 2px solid var(--main-color);
    border-radius: 12px;
    padding: 10px 15px;
    background: #111;
    font-size: 14px;
    user-select: none;
  }
  #leaderboardContainer h3 {
    margin: 0 0 10px 0;
    font-weight: normal;
  }
  #leaderboardList {
    list-style: none;
    padding-left: 12px;
    margin: 0;
    max-height: 130px;
    overflow-y: auto;
  }
  #leaderboardList li {
    margin-bottom: 6px;
  }
  /* Credits display */
  #creditsDisplay {
    margin-top: 15px;
    width: 340px;
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    user-select: none;
  }

  /* Upgrades tab */
  #upgradesTab {
    position: fixed;
    top: 0;
    left: -360px;
    width: 360px;
    height: 100vh;
    background: #000;
    border-right: 2px solid var(--main-color);
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    overflow-y: auto;
    padding: 20px 15px;
    box-sizing: border-box;
    transition: left 0.3s ease;
    z-index: 100;
    display: flex;
    flex-direction: column;
  }
  #upgradesTab.visible {
    left: 0;
  }
  #upgradesTab h2 {
    text-align: center;
    margin-bottom: 15px;
  }
  .upgradeItem {
    border: 2px solid var(--main-color);
    padding: 10px;
    margin-bottom: 10px;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .upgradeItem .details {
    flex-grow: 1;
    text-align: left;
  }
  .upgradeItem .details p {
    margin: 3px 0;
    font-size: 13px;
  }
  .upgradeItem button {
    background: none;
    border: 2px solid var(--main-color);
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    cursor: pointer;
    font-size: 14px;
    padding: 8px 15px;
    border-radius: 10px;
    min-width: 100px;
  }
  .upgradeItem button:disabled {
    border-color: #555;
    color: #555;
    cursor: default;
  }
  /* Scrollbar styling */
  #upgradesTab::-webkit-scrollbar {
    width: 8px;
  }
  #upgradesTab::-webkit-scrollbar-thumb {
    background: var(--main-color);
    border-radius: 4px;
  }

  /* Shop and Options tabs */
  #shopTab, #optionsTab {
    position: fixed;
    top: 0;
    left: -360px;
    width: 360px;
    height: 100vh;
    background: #000;
    border-right: 2px solid var(--main-color);
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    overflow-y: auto;
    padding: 20px 15px;
    box-sizing: border-box;
    transition: left 0.3s ease;
    z-index: 100;
  }
  #shopTab.visible, #optionsTab.visible {
    left: 0;
  }
  #shopTab h2, #optionsTab h2 {
    text-align: center;
    margin-bottom: 15px;
  }

  /* Close "X" button for tabs */
  .closeTabBtn {
    position: absolute;
    top: 12px;
    right: 12px;
    background-color: var(--main-color);
    color: #000;
    border: none;
    font-size: 22px;
    font-weight: bold;
    cursor: pointer;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    line-height: 28px;
    text-align: center;
    padding: 0;
    user-select: none;
    transition: background-color 0.3s ease;
    z-index: 110;
  }
  .closeTabBtn:hover, .closeTabBtn:focus {
    background-color: #0c0;
    outline: none;
  }

  /* Options Menu Color Buttons */
  .colorOptionBtn {
    cursor: pointer;
    border: 2px solid var(--main-color);
    background: none;
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    font-size: 14px;
    padding: 10px 15px;
    margin: 6px;
    border-radius: 10px;
    user-select: none;
    transition: background 0.3s;
    width: 140px;
  }
  .colorOptionBtn:hover, .colorOptionBtn.active {
    background: var(--main-color);
    color: #000;
  }

  /* When tab is visible, dim main screen behind */
  #colorSelectionWrapper.dimmed {
    filter: brightness(0.6);
    pointer-events: none;
  }

  /* Other existing UI components */
  #countdown {
    font-size: 48px;
    margin-top: 20px;
    font-weight: bold;
    color: var(--main-color);
    text-shadow:
      0 0 10px var(--main-color),
      0 0 20px var(--main-color),
      0 0 30px var(--main-color);
    font-family: 'PressStart2P', monospace;
  }
  #upgradeInfo {
    position: fixed;
    top: 10px;
    left: 10px;
    background: rgba(0,0,0,0.7);
    padding: 10px 15px;
    border-radius: 8px;
    font-size: 14px;
    line-height: 1.5;
    max-width: 220px;
    z-index: 12;
    display:none;
  }
  #powerupInfo {
    position: fixed;
    top: 150px;
    left: 10px;
    font-style: italic;
    z-index: 12;
    display:none;
  }
  #info {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    max-width: 90vw;
    text-align: center;
    z-index: 10;
    display:none;
  }
  #retryButton {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #000;
    border: 3px solid var(--main-color);
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
    font-size: 18px;
    padding: 12px 25px;
    cursor: pointer;
    border-radius: 10px;
    z-index: 100;
    display: none;
  }
  #highScoreButton {
    position: fixed;
    top: 40px;
    right: 20px;
    z-index: 20;
    background: rgba(0,0,0,0.7);
    border: 2px solid var(--main-color);
    color: var(--main-color);
    padding: 10px 15px;
    font-family: 'PressStart2P', monospace;
    cursor: pointer;
    border-radius: 10px;
    display: none;
  }
  #highScoreModal {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: #000;
    border: 3px solid var(--main-color);
    padding: 30px;
    z-index: 50;
    display: none;
    max-width: 400px;
    width: 90vw;
    color: var(--main-color);
    font-family: 'PressStart2P', monospace;
  }
  #highScoreModal h2 {
    margin-top: 0;
    margin-bottom: 20px;
  }
  #closeHighScore {
    cursor: pointer;
    background: var(--main-color);
    color: #000;
    border-radius: 6px;
    padding: 5px 10px;
    font-weight: bold;
    margin-top: 20px;
    display: inline-block;
  }
  #flashOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #fff;
    opacity: 0.8;
    display: none;
    pointer-events: none;
    z-index: 150;
  }

  /* Themes section inside Options tab */
  #optionsTab .themesContainer {
    margin-top: 30px;
    text-align: center;
    user-select: none;
  }
  #optionsTab #themeButtonsContainer {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 8px;
    margin-bottom: 15px;
  }
  #optionsTab #themeButtonsContainer button.colorOptionBtn {
    width: 110px;
    font-size: 13px;
  }
  #optionsTab #themePreview {
    max-width: 300px;
    margin: 0 auto;
    text-align: left;
    font-size: 14px;
    color: var(--main-color);
    border: 2px solid var(--main-color);
    border-radius: 10px;
    padding: 10px;
  }
</style>
</head>
<body>

<div id="colorSelectionWrapper">
  <div id="leftMenu">
    <button id="btnUpgrades" class="active">Upgrades</button>
    <button id="btnShop">Shop</button>
    <button id="btnOptions">Options</button>
  </div>

  <div id="colorSelectionScreen" tabindex="0">
    <div>Select Your Colors & Ready Up</div>
    <div id="creditsDisplay">Credits: 0</div>
    <div id="colorOptions">
      <div class="colorBox" style="background:#00f;" data-color="#00f"></div>
      <div class="colorBox" style="background:#0ff;" data-color="#0ff"></div>
      <div class="colorBox" style="background:#f00;" data-color="#f00"></div>
      <div class="colorBox" style="background:#ff0;" data-color="#ff0"></div>
    </div>
    <div id="readyInstructions">
      <div><strong>Player 1:</strong> Use A/D to select color, SPACE to Ready/Unready</div>
      <div><strong>Player 2:</strong> Use Left/Right Arrows to select color, ENTER to Ready/Unready</div>
    </div>
    <div id="modeToggle" title="Press M to toggle Player Mode">Mode: 2 Players (Press M to toggle)</div>

    <!-- Added countdown element -->
    <div id="countdown"></div>

    <div id="difficultySelector">
      <label for="difficultySelect">Select Difficulty:</label>
      <select id="difficultySelect" title="Select difficulty">
        <option value="easy">Easy</option>
        <option value="normal" selected>Normal</option>
        <option value="hard">Hard</option>
        <option value="custom">Custom</option>
      </select>

      <div id="customSliders" style="display:none; margin-top:15px;">
        <div class="sliderContainer">
          <label for="powerupDropSlider">Powerup Drop Chance</label>
          <input type="range" id="powerupDropSlider" min="0" max="2" step="1" value="1" title="0=Normal,1=High,2=Very High">
          <div style="font-size:10px;">0=Normal, 1=High, 2=Very High</div>
        </div>
        <div class="sliderContainer">
          <label for="enemySpeedSlider">Enemy Movement Multiplier (0.5x - 5x)</label>
          <input type="range" id="enemySpeedSlider" min="0.5" max="5" step="0.1" value="1" title="Enemy speed multiplier">
        </div>
        <div class="sliderContainer">
          <label for="bulletDamageSlider">Bullet Damage (0.5x - 5x)</label>
          <input type="range" id="bulletDamageSlider" min="0.5" max="5" step="0.1" value="1" title="Bullet damage multiplier">
        </div>
        <div class="sliderContainer">
          <label for="bulletSpeedSlider">Bullet Speed (0.5x - 5x)</label>
          <input type="range" id="bulletSpeedSlider" min="0.5" max="5" step="0.1" value="1" title="Bullet speed multiplier">
        </div>
        <div class="sliderContainer">
          <label for="bulletSizeSlider">Bullet Size (0.5x - 5x)</label>
          <input type="range" id="bulletSizeSlider" min="0.5" max="5" step="0.1" value="1" title="Bullet size multiplier">
        </div>
        <div class="sliderContainer">
          <label for="playerSpeedSlider">Player Speed (0.5x - 5x)</label>
          <input type="range" id="playerSpeedSlider" min="0.5" max="5" step="0.1" value="1" title="Player speed multiplier">
        </div>
        <div class="sliderContainer">
          <label for="playerHealthSlider">Player Health (0.5x - 5x)</label>
          <input type="range" id="playerHealthSlider" min="0.5" max="5" step="0.1" value="1" title="Player health multiplier">
        </div>
        <div class="sliderContainer">
          <label for="bossSpawnSlider">Boss Spawn Rate</label>
          <input type="range" id="bossSpawnSlider" min="0" max="2" step="1" value="1" title="0=Normal,1=High,2=Very High">
          <div style="font-size:10px;">0=Normal, 1=High, 2=Very High</div>
        </div>
      </div>
    </div>

    <div id="blitzToggleContainer" title="Toggle Blitz Mode">
      <label for="blitzCheckbox">Blitz Mode</label>
      <input type="checkbox" id="blitzCheckbox" />
    </div>

    <div id="leaderboardContainer" title="Top 5 High Scores">
      <h3>Leaderboard</h3>
      <ul id="leaderboardList">
        <li>Loading...</li>
      </ul>
    </div>
  </div>
</div>

<!-- Tabs for Upgrades / Shop / Options -->

<div id="upgradesTab" tabindex="0">
  <button class="closeTabBtn" aria-label="Close Upgrades Tab">✕</button>
  <h2>Upgrades</h2>
  <div id="creditsInfo" style="text-align:center; font-size:16px; margin-bottom:15px;">Credits: 0</div>
  <div id="upgradeList"></div>
  <div style="font-size:12px; margin-top:10px; line-height:1.3; max-width:400px; margin-left:auto; margin-right:auto;">
    <strong>Note:</strong> Each upgrade has 10 tiers. Costs double with each purchase.<br>
    Double Credits: earns double credits per kill per tier (1x2 per tier).<br>
    Player Speed, Health, Bullet Damage, Bullet Speed, Power-Up Spawn Rates boost stats.<br>
    Second Life: grants one extra life if health reaches 0 in single player.<br>
    Unlock Dash: double tap shoot button to dash; duration +0.2s per tier.<br>
  </div>
</div>
<div id="shopTab" tabindex="0">
  <button class="closeTabBtn" aria-label="Close Shop Tab">✕</button>
  <h2>Shop</h2>
  <p style="text-align:center;">Shop coming soon!</p>
</div>
<div id="optionsTab" tabindex="0">
  <button class="closeTabBtn" aria-label="Close Options Tab">✕</button>
  <h2>Options</h2>
  <div style="text-align:center; margin-top: 10px; font-size: 14px;">
    <p>Choose Menu Color Theme:</p>
    <div style="display:flex; flex-wrap: wrap; justify-content: center; gap: 10px; margin-top: 10px;">
      <button class="colorOptionBtn active" data-color="#0f0">Native Green</button>
      <button class="colorOptionBtn" data-color="#00aaff">Retro Blue</button>
      <button class="colorOptionBtn" data-color="#ff3300">Retro Red</button>
      <button class="colorOptionBtn" data-color="#eeeeee">Retro White</button>
      <button class="colorOptionBtn" data-color="#aa00ff">Retro Purple</button>
      <button class="colorOptionBtn" data-color="#ff69b4">Retro Pink</button>
    </div>
  </div>
  <!-- Themes section moved here -->
  <div class="themesContainer">
    <p><strong>Themes:</strong></p>
    <div id="themeButtonsContainer"></div>
    <div id="themePreview">
      <div><strong>Players:</strong> <span id="playersColorsPreview">(None selected)</span></div>
      <div style="margin-top:8px;"><strong>Enemies:</strong> <span id="enemiesColorsPreview">(None selected)</span></div>
</div>
</div>
<div style="margin-top:15px; text-align:center;">
  <label><input type="checkbox" id="disableNukeFlash"> Disable Nuke Flash</label>
</div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="upgradeInfo" style="display:none;"></div>
<div id="powerupInfo" style="display:none;"></div>
<div id="info" style="display:none;">
  <div>
    Player 1: Move (W A S D), Shoot (SPACE) | Player 2: Move (Arrow Keys), Shoot (ENTER)
  </div>
</div>

<button id="highScoreButton">High Scores</button>
<button id="retryButton">Retry</button>

<div id="upgradePrompt" style="z-index: 101; display:none;">
  <p><strong>Upgrade earned! Press the key for the upgrade you want:</strong></p>
  <p>1: Bullet Damage</p>
  <p>2: Bullet Speed</p>
  <p>3: Health Boost</p>
  <p>4: Speed Boost</p>
</div>

<div id="progressBarContainer" style="display:none;" title="Progress to next upgrade">
  <div id="progressBarFill"></div>
</div>

<div id="flashOverlay"></div>

<div id="highScoreModal">
  <h2>High Scores</h2>
  <ol id="highScoreList"></ol>
  <div id="closeHighScore">Close</div>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  const upgradeInfo = document.getElementById('upgradeInfo');
  const powerupInfo = document.getElementById('powerupInfo');
  const upgradePrompt = document.getElementById('upgradePrompt');
  const progressBarContainer = document.getElementById('progressBarContainer');
  const progressBarFill = document.getElementById('progressBarFill');
  const flashOverlay = document.getElementById('flashOverlay');

  const colorSelectionWrapper = document.getElementById('colorSelectionWrapper');
  const colorSelectionScreen = document.getElementById('colorSelectionScreen');
  const colorBoxes = [...document.querySelectorAll('.colorBox')];
  const countdownElem = document.getElementById('countdown');
  const modeToggle = document.getElementById('modeToggle');
  const blitzCheckbox = document.getElementById('blitzCheckbox');
  const leaderboardList = document.getElementById('leaderboardList');
  const creditsDisplay = document.getElementById('creditsDisplay');
  const upgradesTab = document.getElementById('upgradesTab');
  const shopTab = document.getElementById('shopTab');
  const optionsTab = document.getElementById('optionsTab');
  const leftMenuButtons = {
    upgrades: document.getElementById('btnUpgrades'),
    shop: document.getElementById('btnShop'),
    options: document.getElementById('btnOptions'),
  };
  const upgradeListDiv = document.getElementById('upgradeList');
  const creditsInfo = document.getElementById('creditsInfo');

  const highScoreButton = document.getElementById('highScoreButton');
  const themeButtonsContainer = document.getElementById("themeButtonsContainer");
  const playersColorsPreview = document.getElementById("playersColorsPreview");
  const enemiesColorsPreview = document.getElementById("enemiesColorsPreview");
  const disableNukeFlashCheckbox = document.getElementById("disableNukeFlash");
  const retryButton = document.getElementById('retryButton');
  const highScoreModal = document.getElementById('highScoreModal');
  const highScoreList = document.getElementById('highScoreList');
  const closeHighScore = document.getElementById('closeHighScore');

  const difficultySelect = document.getElementById('difficultySelect');
  const customSliders = document.getElementById('customSliders');

  // Custom sliders
  const powerupDropSlider = document.getElementById('powerupDropSlider');
  const enemySpeedSlider = document.getElementById('enemySpeedSlider');
  const bulletDamageSlider = document.getElementById('bulletDamageSlider');
  const bulletSpeedSlider = document.getElementById('bulletSpeedSlider');
  const bulletSizeSlider = document.getElementById('bulletSizeSlider');
  const playerSpeedSlider = document.getElementById('playerSpeedSlider');
  const playerHealthSlider = document.getElementById('playerHealthSlider');
  const bossSpawnSlider = document.getElementById('bossSpawnSlider');

  // Player selection and mode state
  let p1Index = 0;
  let p2Index = colorBoxes.length - 1;
  let p1Ready = false;
  let p2Ready = false;
  let countdownTimeout = null;
  let countdownNum = 3;
  let gameStarted = false;
  let onePlayerMode = false;

  // Difficulty settings (defaults for Normal)
  let powerupDropChance = 0.8;
  let enemyMovementMultiplierBase = 1;
  let bulletDamageMultiplierBase = 1;
  let bulletSpeedMultiplierBase = 1;
  let bulletSizeMultiplierBase = 1;
  let playerSpeedMultiplierBase = 1;
  let playerHealthMultiplierBase = 1;
  let bossSpawnRateIndex = 1; // Normal

  // --- Spawn interval and Blitz mode ---
  const SPAWN_INTERVAL = 2000;  // base spawn interval in ms
  let spawnIntervalBase = SPAWN_INTERVAL;  // base value, never changes
  let spawnIntervalCurrent = SPAWN_INTERVAL;  // current interval adjusted by kills and blitz
  let blitzMode = false;  // Blitz mode off by default

  // Upgrade and credits system
  let credits = 0;
  // Upgrade tiers stored as { upgradeKey: tierNumber (1-10) }
  // Load or init from localStorage
  let upgradeTiers = JSON.parse(localStorage.getItem('pzombieUpgrades') || '{}');
  const MAX_TIER = 10;

  // Upgrade definitions
  const UPGRADES = [
    { key: 'doubleCredits', name: 'Double Credits', baseCost: 10,
      description: 'Earn double credits per kill per tier (1x2 per tier)' },
    { key: 'playerSpeed', name: 'Player Speed', baseCost: 5,
      description: 'Increase player speed off spawn' },
    { key: 'playerHealth', name: 'Player Health', baseCost: 10,
      description: 'Increase player health off spawn' },
    { key: 'bulletDamage', name: 'Bullet Damage', baseCost: 15,
      description: 'Increase bullet damage off spawn' },
    { key: 'bulletSpeed', name: 'Bullet Speed', baseCost: 10,
      description: 'Increase bullet speed off spawn' },
    { key: 'powerupSpawnRate', name: 'Power-Up Spawn Rates', baseCost: 25,
      description: 'Increase chances of power-ups spawning' },
    { key: 'secondLife', name: 'Second Life (1P Only)', baseCost: 250,
      description: 'Get one extra life if health reaches 0 in single player' },
    { key: 'unlockDash', name: 'Unlock Dash', baseCost: 100,
      description: 'Double tap shoot button to dash; duration +0.2s per tier' },
  ];

  // Credits earned per kill base value (affected by doubleCredits upgrade)
  const BASE_CREDITS_PER_KILL = 1;

  // Leaderboard cache
  let leaderboardScores = [];

  // Game constants
  const BASE_PLAYER_SIZE = 30;
  const BASE_PLAYER_SPEED = 4;
  const BASE_BULLET_SPEED = 8;
  const BASE_BULLET_DAMAGE = 10;
  const BASE_ZOMBIE_SIZE = 30;
  const BASE_ZOMBIE_SPEED = 1.5;
  const MAX_HEALTH = 100;
  const CRIT_CHANCE = 0.1;

  // Theme definitions
  const THEMES = [
    { name: "Classic", players: ["#00f","#0ff","#f00","#ff0"], enemies: ["#900","#b22","#f00"] },
    { name: "Night", players: ["#0f0","#ff0","#0ff","#fff"], enemies: ["#0b0","#0d0","#0f0"] }
  ];
  let currentTheme = parseInt(localStorage.getItem("zbThemeIndex") || "0", 10);
  if (isNaN(currentTheme) || currentTheme >= THEMES.length) currentTheme = 0;
  let zombieColor = THEMES[currentTheme].enemies[0];
  let miniBossColor = THEMES[currentTheme].enemies[1];
  let bossColor = THEMES[currentTheme].enemies[2];
  // Game variables

  let player1, player2;
  let kills, totalKills, nextUpgradeThreshold, enemySpeedMultiplier, upgradeLevel;
  let activePowerups;
  let zombies, powerups;
  let lastSpawn, gameOver, win;
  let upgradePoints, awaitingUpgrade;

  // Dash variables for unlockDash
  let lastShootTimeP1 = 0;
  let lastShootTimeP2 = 0;
  let dashDurationBase = 200; // ms
  let player1Dashing = false;
  let player2Dashing = false;
  let dashTimerP1 = 0;
  let dashTimerP2 = 0;
  let dashSpeedMultiplier = 3;

  // Utility functions
  function rectCollision(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
  }
  function circleRectCollision(circle, rect) {
    let distX = Math.abs(circle.x - rect.x - rect.width/2);
    let distY = Math.abs(circle.y - rect.y - rect.height/2);
    if (distX > (rect.width/2 + circle.radius)) return false;
    if (distY > (rect.height/2 + circle.radius)) return false;
    if (distX <= (rect.width/2)) return true;
    if (distY <= (rect.height/2)) return true;
    let dx = distX - rect.width/2;
    let dy = distY - rect.height/2;
    return (dx*dx + dy*dy <= (circle.radius * circle.radius));
  }

  function saveCredits() {
    localStorage.setItem('pzombieCredits', credits.toString());
  }
  function loadCredits() {
    credits = parseInt(localStorage.getItem('pzombieCredits') || '0', 10);
    if (isNaN(credits)) credits = 0;
  }
  function saveUpgrades() {
    localStorage.setItem('pzombieUpgrades', JSON.stringify(upgradeTiers));
  }
  function loadUpgrades() {
    const saved = JSON.parse(localStorage.getItem('pzombieUpgrades') || '{}');
    upgradeTiers = saved;
    // ensure all keys exist with minimum 0
    UPGRADES.forEach(u => {
      if (!upgradeTiers[u.key]) upgradeTiers[u.key] = 0;
    });
  }

  // Calculate cost of an upgrade for next tier
  function upgradeCost(baseCost, tier) {
    // cost doubles per tier, tier 1 = baseCost * 2^0 = baseCost
    return baseCost * Math.pow(2, tier);
  }

  // Update credits display on color selection and upgrades tab
  function updateCreditsDisplay() {
    creditsDisplay.textContent = `Credits: ${credits}`;
    creditsInfo.textContent = `Credits: ${credits}`;
  }

  // Render upgrades UI
  function renderUpgrades() {
    upgradeListDiv.innerHTML = '';
    UPGRADES.forEach(upgrade => {
      const tier = upgradeTiers[upgrade.key] || 0;
      const nextTier = tier + 1;
      const canBuy = nextTier <= MAX_TIER && credits >= upgradeCost(upgrade.baseCost, tier);
      const cost = nextTier <= MAX_TIER ? upgradeCost(upgrade.baseCost, tier) : '-';

      const itemDiv = document.createElement('div');
      itemDiv.className = 'upgradeItem';

      const detailsDiv = document.createElement('div');
      detailsDiv.className = 'details';

      detailsDiv.innerHTML = `<strong>${upgrade.name}</strong> (Tier ${tier}/${MAX_TIER})<br><small>${upgrade.description}</small>`;

      const buyBtn = document.createElement('button');
      buyBtn.textContent = nextTier <= MAX_TIER ? `Buy (${cost} Credits)` : 'Maxed';
      buyBtn.disabled = !canBuy;

      buyBtn.onclick = () => {
        if (credits >= cost && nextTier <= MAX_TIER) {
          credits -= cost;
          upgradeTiers[upgrade.key] = nextTier;
          saveCredits();
          saveUpgrades();
          updateCreditsDisplay();
          renderUpgrades();
        }
      };

      itemDiv.appendChild(detailsDiv);
      itemDiv.appendChild(buyBtn);
      upgradeListDiv.appendChild(itemDiv);
    });
  }

  // Update leaderboard UI from localStorage
  function updateLeaderboard() {
    const scores = JSON.parse(localStorage.getItem('pzombieHighScores') || '[]');
    leaderboardScores = scores;
    if (scores.length === 0) {
      leaderboardList.innerHTML = '<li>No scores yet.</li>';
      return;
    }
    leaderboardList.innerHTML = scores
      .slice(0,5)
      .map((score, i) => `<li>#${i+1} - ${score} Kills</li>`)
      .join('');
  }

  function applyTheme(index) {
    currentTheme = index;
    localStorage.setItem('zbThemeIndex', currentTheme);
    const theme = THEMES[currentTheme];
    zombieColor = theme.enemies[0];
    miniBossColor = theme.enemies[1];
    bossColor = theme.enemies[2];
    colorBoxes.forEach((box, i) => {
      if (theme.players[i]) {
        box.style.background = theme.players[i];
        box.dataset.color = theme.players[i];
      }
    });
    playersColorsPreview.textContent = theme.players.join(', ');
    enemiesColorsPreview.textContent = theme.enemies.join(', ');
    themeButtonsContainer.querySelectorAll('button').forEach((b, bi) => {
      if (bi === index) b.classList.add('active');
      else b.classList.remove('active');
    });
  }

  // Tab management with slide animation
  let activeTab = null;
  function openTab(tabName) {
    // Close previously open tab if any
    if (activeTab) {
      const oldTab = document.getElementById(activeTab + 'Tab');
      if (oldTab) oldTab.classList.remove('visible');
    }
    if (activeTab === tabName) {
      // Same tab clicked again, close it
      activeTab = null;
      colorSelectionWrapper.classList.remove('dimmed');
      colorSelectionScreen.focus();
      updateActiveButton(null);
      return;
    }
    // Open new tab
    activeTab = tabName;
    const tab = document.getElementById(tabName + 'Tab');
    if (tab) tab.classList.add('visible');

    // Dim main screen behind
    colorSelectionWrapper.classList.add('dimmed');

    // Remove focus from color selection to avoid accidental input
    colorSelectionScreen.blur();

    // Focus on the opened tab for keyboard input (if needed)
    tab.focus && tab.focus();

    updateActiveButton(tabName);
  }

  // Update left menu buttons active state
  function updateActiveButton(tabName) {
    Object.entries(leftMenuButtons).forEach(([key, btn]) => {
      if (key === tabName) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    });
  }

  // Setup event listeners for left menu
  leftMenuButtons.upgrades.onclick = () => openTab('upgrades');
  leftMenuButtons.shop.onclick = () => openTab('shop');
  leftMenuButtons.options.onclick = () => openTab('options');

  // Close tab buttons handlers
  document.querySelectorAll('.closeTabBtn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (!activeTab) return;
      const tab = document.getElementById(activeTab + 'Tab');
      if (tab) tab.classList.remove('visible');
      activeTab = null;
      colorSelectionWrapper.classList.remove('dimmed');
      colorSelectionScreen.focus();
      updateActiveButton(null);
    });
  });

  // Keyboard support for toggling tabs with ESC key to close any open tab
  window.addEventListener('keydown', e => {
    if (activeTab) {
      if (e.code === 'Escape' || e.key === 'Escape') {
        // Close open tab
        const tab = document.getElementById(activeTab + 'Tab');
        if (tab) tab.classList.remove('visible');
        activeTab = null;
        colorSelectionWrapper.classList.remove('dimmed');
        colorSelectionScreen.focus();
        updateActiveButton(null);
        e.preventDefault();
      }
    }
  });

  // Resize canvas to full viewport size dynamically
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);

  // Call once immediately
  resizeCanvas();

  // Set focus on the color selection screen on load
  window.addEventListener('load', () => {
    colorSelectionScreen.focus();
    loadCredits();
    loadUpgrades();
    updateCreditsDisplay();
    renderUpgrades();
    updateLeaderboard();
    blitzMode = blitzCheckbox.checked;
    THEMES.forEach((t,i) => {
      const b = document.createElement('button');
      b.className = 'colorOptionBtn';
      b.textContent = t.name;
      b.addEventListener('click', () => applyTheme(i));
      themeButtonsContainer.appendChild(b);
    });
    applyTheme(currentTheme);
    disableNukeFlashCheckbox.checked = JSON.parse(localStorage.getItem('disableNukeFlash') || 'false');
    updateUpgradeInfo();
  });

  // Keyboard input tracking and game controls

  const keys = {};
  window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (gameStarted) e.preventDefault();
  });
  window.addEventListener('keyup', e => {
    keys[e.code] = false;
    if (gameStarted) e.preventDefault();
  });
  window.addEventListener('keydown', e => { if (e.code === 'KeyN') triggerNuke(); });

  // Update selection UI
  function updateColorSelectionUI() {
    colorBoxes.forEach((box, i) => {
      box.classList.remove('p1-selected', 'p2-selected', 'p1-ready', 'p2-ready');
      if (i === p1Index) box.classList.add('p1-selected');
      if (i === p2Index && !onePlayerMode) box.classList.add('p2-selected');
    });
    if (p1Ready) colorBoxes[p1Index].classList.add('p1-ready');
    if (p2Ready) colorBoxes[p2Index].classList.add('p2-ready');
  }
  updateColorSelectionUI();

  function clearCountdown() {
    countdownElem.textContent = '';
    if (countdownTimeout) {
      clearTimeout(countdownTimeout);
      countdownTimeout = null;
    }
    countdownNum = 3;
  }

  function startCountdown() {
    if (countdownTimeout) return;

    function tick() {
      if (!p1Ready || (!p2Ready && !onePlayerMode)) {
        clearCountdown();
        return;
      }
      if (countdownNum === 0) {
        countdownElem.textContent = '';
        startGame();
        return;
      }
      countdownElem.textContent = countdownNum;
      countdownNum--;
      countdownTimeout = setTimeout(tick, 1000);
    }
    tick();
  }

  // Handle keyboard inputs in color selection screen and tabs for player controls and ready states
  window.addEventListener('keydown', e => {
    // Only handle keys if game NOT started and no tab is open or if tab is upgrades/shop/options, keys should still work
    if (!gameStarted) {
      // Player 1: A/D to move, Space to ready/unready, M to toggle mode
      if (['KeyA','KeyD','Space','KeyM'].includes(e.code)) {
        if (e.code === 'KeyA' && !p1Ready) {
          p1Index = (p1Index - 1 + colorBoxes.length) % colorBoxes.length;
          updateColorSelectionUI();
          clearCountdown();
        }
        if (e.code === 'KeyD' && !p1Ready) {
          p1Index = (p1Index + 1) % colorBoxes.length;
          updateColorSelectionUI();
          clearCountdown();
        }
        if (e.code === 'Space') {
          p1Ready = !p1Ready;
          updateColorSelectionUI();
          if (p1Ready && (p2Ready || onePlayerMode)) {
            startCountdown();
          } else {
            clearCountdown();
          }
        }
        if (e.code === 'KeyM') {
          onePlayerMode = !onePlayerMode;
          if (onePlayerMode) {
            p2Ready = true; // auto ready for 1p
            modeToggle.textContent = 'Mode: 1 Player (Press M to toggle)';
          } else {
            p2Ready = false;
            modeToggle.textContent = 'Mode: 2 Players (Press M to toggle)';
          }
          updateColorSelectionUI();
          clearCountdown();
        }
        e.preventDefault();
        return;
      }

      // Player 2: Left/Right arrows to move, Enter to ready/unready (ignored in 1p mode)
      if (!onePlayerMode && ['ArrowLeft','ArrowRight','Enter'].includes(e.code)) {
        if (e.code === 'ArrowLeft' && !p2Ready) {
          p2Index = (p2Index - 1 + colorBoxes.length) % colorBoxes.length;
          updateColorSelectionUI();
          clearCountdown();
        }
        if (e.code === 'ArrowRight' && !p2Ready) {
          p2Index = (p2Index + 1) % colorBoxes.length;
          updateColorSelectionUI();
          clearCountdown();
        }
        if (e.code === 'Enter') {
          p2Ready = !p2Ready;
          updateColorSelectionUI();
          if (p1Ready && p2Ready) {
            startCountdown();
          } else {
            clearCountdown();
          }
        }
        e.preventDefault();
        return;
      }
    }
  });

  // Player class with movement, shooting, bullets, and draw
  class Player {
    constructor(x, y, color, controls, side) {
      this.x = x;
      this.y = y;
      this.color = color;
      this.controls = controls;
      this.health = MAX_HEALTH * playerHealthMultiplierBase;
      this.width = BASE_PLAYER_SIZE;
      this.height = BASE_PLAYER_SIZE;
      this.bullets = [];
      this.shootCooldown = 0;
      this.side = side;

      this.bulletDamage = BASE_BULLET_DAMAGE * bulletDamageMultiplierBase;
      this.bulletSpeed = BASE_BULLET_SPEED * bulletSpeedMultiplierBase;
      this.bulletSize = 5 * bulletSizeMultiplierBase;
      this.speed = BASE_PLAYER_SPEED * playerSpeedMultiplierBase;
      this.maxHealth = MAX_HEALTH * playerHealthMultiplierBase;
    }
    move() {
      const centerX = canvas.width / 2;
      if (keys[this.controls.up] && this.y > 0) this.y -= this.speed;
      if (keys[this.controls.down] && this.y + this.height < canvas.height) this.y += this.speed;

      if (onePlayerMode) {
        if (keys[this.controls.left] && this.x > 0) this.x -= this.speed;
        if (keys[this.controls.right] && this.x + this.width < canvas.width) this.x += this.speed;
      } else {
        if (keys[this.controls.left]) {
          if (this.side === 'left') {
            if (this.x > 0) this.x -= this.speed;
          } else if (this.side === 'right') {
            if (this.x - this.speed >= centerX) this.x -= this.speed;
          }
        }
        if (keys[this.controls.right]) {
          if (this.side === 'left') {
            if (this.x + this.width + this.speed <= centerX) this.x += this.speed;
          } else if (this.side === 'right') {
            if (this.x + this.width < canvas.width) this.x += this.speed;
          }
        }
      }

      // Clamp position inside canvas
      this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
      this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
    }
    shoot() {
      if (keys[this.controls.shoot] && this.shootCooldown <= 0) {
        let dir = this.controls.shootDir;
        if (onePlayerMode) {
          let dx = 0, dy = 0;
          if (keys[this.controls.up]) dy = -1;
          else if (keys[this.controls.down]) dy = 1;
          if (keys[this.controls.left]) dx = -1;
          else if (keys[this.controls.right]) dx = 1;
          if (dx === 0 && dy === 0) {
            dx = 1; dy = 0;
          }
          const mag = Math.sqrt(dx*dx + dy*dy);
          dir = {x: dx/mag, y: dy/mag};
        }
        this.bullets.push(new Bullet(
          this.x + this.width/2,
          this.y + this.height/2,
          dir,
          activePowerups.rapidFire ? this.bulletSpeed * 1.5 : this.bulletSpeed,
          this.bulletDamage,
          this.bulletSize
        ));
        this.shootCooldown = 20;
      }
      if (this.shootCooldown > 0) this.shootCooldown--;
    }
    updateBullets() {
      this.bullets.forEach((b, i) => {
        b.move();
        if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
          this.bullets.splice(i, 1);
        }
      });
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      drawHealthBar(this.x, this.y - 12, this.width, 6, this.health, this.maxHealth);
      this.bullets.forEach(b => b.draw());
    }
  }

  class Bullet {
    constructor(x, y, direction, speed, damage, size = 5) {
      this.x = x;
      this.y = y;
      this.radius = size;
      this.speed = speed;
      this.direction = direction;
      this.damage = damage;
      this.crit = Math.random() < CRIT_CHANCE;
    }
    move() {
      this.x += this.speed * this.direction.x;
      this.y += this.speed * this.direction.y;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = this.crit ? '#ff69b4' : '#ff0';
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      if (this.crit) {
        ctx.strokeStyle = '#ff69b4';
        ctx.lineWidth = 2;
        ctx.stroke();
      }
    }
  }

  class Zombie {
    constructor(x, y, size = BASE_ZOMBIE_SIZE, speed = BASE_ZOMBIE_SPEED, health = 20) {
      this.x = x;
      this.y = y;
      this.width = size;
      this.height = size;
      this.color = zombieColor;
      this.speed = speed;
      this.health = health;
      this.maxHealth = health;
      this.target = null;
    }
    move() {
      if (!this.target) return;
      let dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
      let dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > 0) {
        this.x += (dx / dist) * this.speed * enemySpeedMultiplier;
        this.y += (dy / dist) * this.speed * enemySpeedMultiplier;
      }
    }
    draw() {
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x, this.y, this.width, this.height);
      drawHealthBar(this.x, this.y - 12, this.width, 6, this.health, this.maxHealth);
    }
  }

  class MiniBoss extends Zombie {
    constructor(x, y) {
      const size = BASE_ZOMBIE_SIZE;
      const health = 20 * 2.5 * playerHealthMultiplierBase;
      super(x, y, size, BASE_ZOMBIE_SPEED, health);
      this.color = miniBossColor;
    }
  }

  class Boss extends Zombie {
    constructor(x, y) {
      const size = BASE_ZOMBIE_SIZE * 3;
      const baseSpeed = BASE_ZOMBIE_SPEED;
      const health = 20 * 5 * playerHealthMultiplierBase;
      const speed = (baseSpeed * enemySpeedMultiplier) * 0.5;
      super(x, y, size, speed, health);
      this.color = bossColor;
    }
    move() {
      if (!this.target) return;
      let dx = this.target.x + this.target.width/2 - (this.x + this.width/2);
      let dy = this.target.y + this.target.height/2 - (this.y + this.height/2);
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist > 0) {
        this.x += (dx / dist) * this.speed;
        this.y += (dy / dist) * this.speed;
      }
    }
  }

  class Powerup {
    constructor(x, y, type) {
      this.x = x;
      this.y = y;
      this.radius = 12;
      this.type = type; // 'nuke', 'rapidFire', 'healthKit', 'megaHealthKit'
      this.color = type === 'nuke' ? '#fff' :
                   type === 'rapidFire' ? '#0ff' :
                   type === 'healthKit' ? '#0f0' :
                   '#ff0';
      this.duration = 15000;
      this.spawnTime = Date.now();
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = this.color;
      ctx.shadowColor = '#0f0';
      ctx.shadowBlur = 10;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#000';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      let symbol = this.type === 'nuke' ? 'N' :
                   this.type === 'rapidFire' ? 'R' :
                   this.type === 'healthKit' ? '+' :
                   this.type === 'megaHealthKit' ? 'M' : '?';
      ctx.fillText(symbol, this.x, this.y);
    }
    isExpired() {
      return (Date.now() - this.spawnTime) > this.duration;
    }
  }

  // Spawn zombie logic (integrated)
  function spawnZombie() {
    const side = Math.random() < 0.5 ? 'left' : 'right';
    const x = side === 'left' ? -BASE_ZOMBIE_SIZE : canvas.width + BASE_ZOMBIE_SIZE;
    const y = Math.random() * (canvas.height - BASE_ZOMBIE_SIZE);

    const distP1 = Math.abs(x - player1.x);
    const distP2 = player2 ? Math.abs(x - player2.x) : Infinity;

    const bossSpawnThresholds = [50, 35, 20];
    const bossSpawnThreshold = bossSpawnThresholds[bossSpawnRateIndex] || 50;

    if (totalKills > 0 && totalKills % bossSpawnThreshold === 0) {
      const boss = new Boss(x, y);
      boss.target = distP1 < distP2 ? player1 : player2;
      zombies.push(boss);
    } else if (totalKills > 0 && totalKills % 10 === 0) {
      const miniboss = new MiniBoss(x, y);
      miniboss.target = distP1 < distP2 ? player1 : player2;
      zombies.push(miniboss);
    } else {
      const z = new Zombie(x, y);
      z.target = distP1 < distP2 ? player1 : player2;
      zombies.push(z);
    }
  }

  function triggerNuke() {
    zombies = [];
    if (!disableNukeFlashCheckbox.checked) {
      flashOverlay.style.display = 'block';
      setTimeout(() => { flashOverlay.style.display = 'none'; }, 300);
    }
  }

  // Health bar helper
  function drawHealthBar(x, y, width, height, current, max) {
    ctx.fillStyle = '#000';
    ctx.fillRect(x - 1, y - 1, width + 2, height + 2);
    const pct = Math.max(0, Math.min(1, current / max));
    ctx.fillStyle = pct > 0.5 ? '#0f0' : pct > 0.2 ? '#ff0' : '#f00';
    ctx.fillRect(x, y, width * pct, height);
  }

  // Initialize player objects at start of game
  function initPlayers() {
    const p1Color = colorBoxes[p1Index].dataset.color || '#00f';
    const p2Color = onePlayerMode ? '#555' : (colorBoxes[p2Index].dataset.color || '#0ff');

    player1 = new Player(canvas.width / 4, canvas.height / 2 - BASE_PLAYER_SIZE / 2, p1Color, {
      up: 'KeyW', down: 'KeyS', left: 'KeyA', right: 'KeyD', shoot: 'Space'
    }, 'left');

    if (!onePlayerMode) {
      player2 = new Player(canvas.width * 3 / 4, canvas.height / 2 - BASE_PLAYER_SIZE / 2, p2Color, {
        up: 'ArrowUp', down: 'ArrowDown', left: 'ArrowLeft', right: 'ArrowRight', shoot: 'Enter'
      }, 'right');
    } else {
      player2 = null;
    }
  }

  // Update upgrade info display (placeholder for showing detailed info)
  function updateUpgradeInfo() {
    upgradeInfo.style.display = 'block';
    upgradeInfo.textContent = `Upgrades Loaded. Credits: ${credits}`;
  }

  // Game variables reset
  function resetGameVars() {
    kills = 0;
    totalKills = 0;
    nextUpgradeThreshold = 10;
    enemySpeedMultiplier = 1;
    upgradeLevel = 0;
    activePowerups = {
      nuke: false,
      rapidFire: false,
      healthKit: false,
      megaHealthKit: false,
    };
    zombies = [];
    powerups = [];
    lastSpawn = 0;
    gameOver = false;
    win = false;
    upgradePoints = 0;
    awaitingUpgrade = false;
  }

  // Start the game after countdown
  function startGame() {
    clearCountdown();
    gameStarted = true;
    colorSelectionWrapper.style.display = 'none';
    canvas.style.display = 'block';
    resizeCanvas(); // ensure canvas size updated
    initPlayers();
    resetGameVars();
    gameLoop();
  }

  // End game logic
  function endGame() {
    gameStarted = false;
    canvas.style.display = 'none';
    colorSelectionWrapper.style.display = 'flex';
    retryButton.style.display = 'inline-block';
    highScoreButton.style.display = 'inline-block';
  }

  // Game loop core
  function gameLoop(timestamp) {
    if (!gameStarted) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Move and draw players
    player1.move();
    player1.shoot();
    player1.updateBullets();
    player1.draw();

    if (player2) {
      player2.move();
      player2.shoot();
      player2.updateBullets();
      player2.draw();
    }

    // Spawn zombies every spawnIntervalCurrent ms
    if (!lastSpawn || timestamp - lastSpawn > spawnIntervalCurrent) {
      spawnZombie();
      lastSpawn = timestamp;
    }

    // Move and draw zombies
    zombies.forEach((z, i) => {
      z.move();
      z.draw();

      // Check collisions with players
      if (player1 && rectCollision(z, player1)) {
        player1.health -= 0.5;
      }
      if (player2 && rectCollision(z, player2)) {
        player2.health -= 0.5;
      }

      // Check if zombies hit by bullets
      [player1, player2].filter(Boolean).forEach(player => {
        player.bullets.forEach((bullet, bIndex) => {
          if (circleRectCollision(bullet, z)) {
            z.health -= bullet.damage;
            player.bullets.splice(bIndex, 1);
            if (z.health <= 0) {
              zombies.splice(i, 1);
              kills++;
              totalKills++;
              credits += BASE_CREDITS_PER_KILL * (1 + (upgradeTiers.doubleCredits || 0) * 2);
              updateCreditsDisplay();
            }
          }
        });
      });
    });

    // Remove dead zombies
    zombies = zombies.filter(z => z.health > 0);

    // Check player health for game over
    if (player1.health <= 0 || (player2 && player2.health <= 0)) {
      endGame();
      return;
    }

    requestAnimationFrame(gameLoop);
  }

  // Button events

  retryButton.addEventListener('click', () => {
    retryButton.style.display = 'none';
    highScoreButton.style.display = 'none';
    p1Ready = false;
    p2Ready = false;
    gameStarted = false;
    colorSelectionWrapper.style.display = 'flex';
    countdownElem.textContent = '';
    updateColorSelectionUI();
  });

  highScoreButton.addEventListener('click', () => {
    // Load scores and show modal
    const scores = JSON.parse(localStorage.getItem('pzombieHighScores') || '[]');
    highScoreList.innerHTML = scores.length > 0 ?
      scores.map((s, i) => `<li>#${i+1}: ${s} Kills</li>`).join('') :
      '<li>No high scores yet.</li>';
    highScoreModal.style.display = 'block';
  });
  closeHighScore.addEventListener('click', () => {
    highScoreModal.style.display = 'none';
  });

  disableNukeFlashCheckbox.addEventListener("change", () => {
    localStorage.setItem("disableNukeFlash", disableNukeFlashCheckbox.checked);
  });
  // Blitz checkbox change event
  blitzCheckbox.addEventListener('change', () => {
    blitzMode = blitzCheckbox.checked;
    // Adjust spawnIntervalCurrent based on blitz
    spawnIntervalCurrent = blitzMode ? spawnIntervalBase / 2 : spawnIntervalBase;
  });

  // Difficulty selector change event
  difficultySelect.addEventListener('change', () => {
    if (difficultySelect.value === 'custom') {
      customSliders.style.display = 'block';
    } else {
      customSliders.style.display = 'none';
      switch (difficultySelect.value) {
        case 'easy':
          powerupDropChance = 1.0;
          enemySpeedMultiplierBase = 0.7;
          bulletDamageMultiplierBase = 0.8;
          bulletSpeedMultiplierBase = 0.8;
          bulletSizeMultiplierBase = 0.8;
          playerSpeedMultiplierBase = 1;
          playerHealthMultiplierBase = 1.3;
          bossSpawnRateIndex = 0;
          break;
        case 'normal':
          powerupDropChance = 0.8;
          enemySpeedMultiplierBase = 1;
          bulletDamageMultiplierBase = 1;
          bulletSpeedMultiplierBase = 1;
          bulletSizeMultiplierBase = 1;
          playerSpeedMultiplierBase = 1;
          playerHealthMultiplierBase = 1;
          bossSpawnRateIndex = 1;
          break;
        case 'hard':
          powerupDropChance = 0.6;
          enemySpeedMultiplierBase = 1.3;
          bulletDamageMultiplierBase = 1.3;
          bulletSpeedMultiplierBase = 1.3;
          bulletSizeMultiplierBase = 1.3;
          playerSpeedMultiplierBase = 1.3;
          playerHealthMultiplierBase = 0.8;
          bossSpawnRateIndex = 2;
          break;
      }
      updateUpgradeInfo();
    }
  });

  // Custom slider changes update multipliers
  [
    powerupDropSlider,
    enemySpeedSlider,
    bulletDamageSlider,
    bulletSpeedSlider,
    bulletSizeSlider,
    playerSpeedSlider,
    playerHealthSlider,
    bossSpawnSlider
  ].forEach(slider => {
    slider.addEventListener('input', () => {
      powerupDropChance = 1.0 - powerupDropSlider.value * 0.2;
      enemySpeedMultiplierBase = parseFloat(enemySpeedSlider.value);
      bulletDamageMultiplierBase = parseFloat(bulletDamageSlider.value);
      bulletSpeedMultiplierBase = parseFloat(bulletSpeedSlider.value);
      bulletSizeMultiplierBase = parseFloat(bulletSizeSlider.value);
      playerSpeedMultiplierBase = parseFloat(playerSpeedSlider.value);
      playerHealthMultiplierBase = parseFloat(playerHealthSlider.value);
      bossSpawnRateIndex = parseInt(bossSpawnSlider.value, 10);
      updateUpgradeInfo();
    });
  });

  // Initial call for difficulty and sliders setup
  difficultySelect.dispatchEvent(new Event('change'));

  // Color selection boxes click handler
  colorBoxes.forEach((box, i) => {
    box.addEventListener('click', () => {
      if (!p1Ready) {
        p1Index = i;
      } else if (!p2Ready && !onePlayerMode) {
        p2Index = i;
      }
      updateColorSelectionUI();
      clearCountdown();
    });
  });

  // Initialize UI states
  updateColorSelectionUI();

})();
</script>

</body>
</html>
